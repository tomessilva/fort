% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ft_helper.R
\encoding{UTF-8}
\name{fort}
\alias{fort}
\title{Create a Fast Orthogonal Random Transform}
\usage{
fort(
  dim_in,
  dim_out = NULL,
  type = "default",
  cache_matrix = TRUE,
  seed = NULL
)
}
\arguments{
\item{dim_in}{Either a scalar indicating the input dimensionality, or a vector of length 2 indicating
the input and output dimensionality of the transform (if dim_out is not specified).}

\item{dim_out}{A scalar indicating the output dimensionality of the transform (not required if the
first parameter is a vector of length 2).}

\item{type}{A string indicating the type of transform to use (optional); current valid options are:
\code{fft2} (i.e. \code{default}).}

\item{cache_matrix}{Logical that controls whether matrices are cached when as.matrix() is called;
should be set to FALSE if saving memory is important (optional, default = TRUE).}

\item{seed}{If set, defines the seed used to generate the random transform (optional, default = NULL).}
}
\value{
An object of a class that inherits from class \link{FastTransform} and which represents a fast
linear transform.
}
\description{
\code{fort()} creates an object (that inherits from class \link{FastTransform}) which represents a fast random
\eqn{\mathbb{R}^{dim\_in} \to \mathbb{R}^{dim\_out}} linear transform. This transform will be
orthonormal when \eqn{dim\_in = dim\_out} \emph{and} they are a power of 2, and approximately
orthogonal or semi-orthogonal (in the sense that either \eqn{W^T W \approx I_{dim\_in}} or
\eqn{W W^T \approx I_{dim\_out}}, if \eqn{W} represents the transform) otherwise.
}
\details{
The goal of \code{fort()} is to provide an easy and efficient way of calculating fast orthogonal random
transforms (when \code{dim_in} is the same as \code{dim_out}) or semi-orthogonal transforms (when \code{dim_in} is
different from \code{dim_out}) within R, by using fast structured transforms (like the Fast Fourier
Transform or the Fast Walsh-Hadamard Transform) to avoid matrix multiplications, in the same spirit
as the Fastfood (Rahimi et al. (2007)), ACDC (Moczulski et al. (2015)), HD (Yu et al. (2016)) and
SD (Choromanski et al. (2017)) families of random structured transforms.

Internally, all \code{fort} transforms assume a blocksize which \emph{must} be a power of 2 and no smaller
than \code{max(dim_in, dim_out)}. The resulting transform will be practically orthonormal when
\eqn{dim\_in = dim\_out} and they match the blocksize of the transform, and practically semi-orthogonal
when \eqn{dim\_in != dim\_out} and \code{max(dim_in, dim_out)} matches the blocksize. Otherwise, these
properties will \emph{only approximately} hold, since the output will result from a decimated
transform (i.e., the rows and columns of the transform should be decorrelated, but not necessarily
orthogonal).
}
\section{\code{fort} transform types}{

The specific type of transform returned depends on the value passed in the \code{type} parameter,
but all methods rely on alternating between applying permutations (complexity \eqn{O(N)}),
diagonal scaling matrices (complexity \eqn{O(N)}) and structured fast linear transforms
(such as the Fast Fourier Transform or the Fast Walsh-Hadamard Transform, which can be
implemented with complexity \eqn{O(N \mathrm{log} N)}). Thus, it becomes possible to reduce the
complexity of transforming an \eqn{\mathbb{R}^N} vector from \eqn{O(N^{2})} (using matrix
multiplication) to \eqn{O(N \mathrm{log} N)}.

Currently, the available options for the \code{type} parameter are:
\itemize{
\item \code{default}: this is the default option, if no \code{type} is specified; currently, it assumes the \code{fft2}
type, but this is subject to change (so avoid this option in non-interactive usage);
\item \code{fft1}: this type of \code{fort} transform uses the Fast Fourier Transform as base transform; for more
technical details, see \link{FastTransformFFT1}.
\item \code{fft2}: this type of \code{fort} transform uses the Fast Fourier Transform as base transform; for more
technical details, see \link{FastTransformFFT2}.
}
}

\section{Using \code{fort} transforms}{

In practice, to apply the fast transform to the columns of a matrix, you should use the \code{\%*\%} operator
as if the output of \code{fort()} was a matrix (e.g., \code{fort(4,6) \%*\% matrix(1:12,4,3)} will output a 6 by 3
matrix that results from applying the transform on the left to the matrix on the right of the \code{\%*\%}
operator).

Objects generated by \code{fort()} are also compatible with other methods applicable to \code{matrix} objects,
such as \code{dim()}, \code{ncol()}, \code{nrow()}, \code{solve()}, \code{t()} and \code{det()}. Furthermore, these object can also
be easily converted to matrices (using \code{as.matrix()}), if required.
}

\examples{
fort(16) # a random orthogonal transform from R^16 to R^16
fort(5, 33) # a random transform from R^5 to R^33
fort(c(5, 33)) # same as previous line
# apply a random orthogonal transformation to the canonical R^4 basis
fort(4) \%*\% diag(4)
}
\references{
Krzysztof M. Choromanski, Mark Rowland, and Adrian Weller. (2017). The unreasonable effectiveness of structured random orthogonal embeddings. \emph{Conference and Workshop on Neural Information Processing Systems}. \url{http://papers.neurips.cc/paper/6626-the-unreasonable-effectiveness-of-structured-random-orthogonal-embeddings}

Felix Xinnan X. Yu, Ananda Theertha Suresh, Krzysztof M. Choromanski, Daniel N. Holtmann-Rice, and Sanjiv Kumar. (2016). Orthogonal random features. \emph{Conference and Workshop on Neural Information Processing Systems}. \url{http://papers.neurips.cc/paper/6246-orthogonal-random-features}

Marcin Moczulski, Misha Denil, Jeremy Appleyard, and Nando de Freitas. (2015). ACDC: A structured efficient linear layer. \url{https://arxiv.org/abs/1511.05946}

Quoc Le, Tamás Sarlós and Alex Smola. (2013). Fastfood - approximating kernel expansions in loglinear time. \emph{International Conference on Machine Learning}. \url{https://proceedings.mlr.press/v28/le13-supp.pdf}
}
\seealso{
\itemize{
\item How to apply \code{fort} transforms: \code{\link{\%*\%.FastTransform}}
\item How to obtain a \code{fort} transform in matrix form: \code{\link[=as.matrix.FastTransform]{as.matrix.FastTransform()}}
\item How to invert \code{fort} transforms: \code{\link[=solve.FastTransform]{solve.FastTransform()}}
\item How to access low-level functionality of \code{fort} transforms: \code{\link{FastTransform}}
}
}
